潜流

LatentFlowx是一种非令牌的、状态驱动的推理运行时，旨在通过以下方式降低计算成本并提高可控性：旨在通过增量状态演化而不是基于标记的历史重新计算。

LatentFlow不是语言模型，也不是代理框架。
它探索了一种不同的推理系统执行路径。

# 为什么选择 LatentFlowx？

现代LLM和代理系统依赖于基于令牌的处理：

背景会随着时间推移而逐渐形成

历史总是不断重演。

注意力成本随序列长度增加而增加

控制和审计都很难。

这导致：

CPU/GPU 使用量的快速增长

长时间环境下的高延迟

有限的正确性保证

审计能力差

LatentFlowx 采用了不同的方法。

核心原则
# 1. 无代币

LatentFlowx不对文本进行分词。

输入被视为：

连续流

语义块

事件或结构化信号

这样就完全避免了代币级别的关注和即时回放。

# 2. 渐进式状态演化

每个输入块都会逐步更新系统：

过去的计算结果永远不会重新计算。

只有新生成的区块才会被处理。

状态演化是明确且可观察的。

这样就产生了O(Δinput)计算，而不是O(history²)。

# 3. 通过状态压缩实现有限内存

LatentFlowx 将内存划分为：

short_history：最近的未压缩数据块

compressed_core：有界潜在状态

原始历史数据不会无限增长。
长期信息会被汇总成结构化的状态。

# 4. 显式成本会计

所有计算都是可测量的：

操作计数

输入字节大小

状态大小演变

模型内部并没有隐藏成本。

# 5. 安全性、控制性和可审计性

LatentFlowx 包含一个StateGuard机制：

对 st 的基于规则的约束

违规行为自动回滚

结构化审计跟踪

所有决策和违规行为都可以以 JSONL 格式记录，
以便用于生产管道（ELK / Datadog）。

LatentFlowx 是什么（以及它不是什么）
LatentFlowx是

非词元推理运行时

增量式和状态驱动式

CPU占用低且开销小。

可解释且可审计

适用于事件流、行为分析和控制系统

# LatentFlowx不是：

语言模型

聊天机器人

基于提示的代理框架

LLM 的替代方案

LatentFlowx 可以作为运行时层与模型和代理共存。

成本比较

LatentFlowx 包含一个可复现的成本比较演示，
该演示以类似代币的基线为基准，重新计算历史记录。

实验（N = 50 个事件）
系统	运营
LatentFlowx（增量式）	50
类令牌基线（历史重放）	1275

操作倍率：约25.5倍

随着输入长度的增加，间隙呈线性增长。

这是结构上的差异，而不是优化技巧。

# 自己运行：

python demo/cost_compare_demo.py

安全与控制（州卫队）

LatentFlowx 通过基于规则的StateGuard来强制执行约束：

每次增量更新后都会运行守卫。

违规行为会触发自动回滚

保护跟踪完全可审计。

# 支持的示例：

最大步数限制

禁止的输入类型

有界状态

这可以防止系统出现不受限制或不安全的行为。

审计与可观测性

LatentFlowx 可以生成适用于生产管道的JSONL 审计日志：

每行一个事件

# 包括：

块指纹（无需原始内容）

状态三角洲

守卫痕迹

回滚事件

决策

# 兼容：

ELK（Filebeat / Logstash）

Datadog Agent

矢量/Fluent Bit

# 运行演示：

python demo/audit_pipeline_demo.py


# 审计日志将写入：

logs/audit.jsonl

演示

# 成本比较

python demo/cost_compare_demo.py


# 防护与回滚展示

python demo/guard_showcase_demo.py


# 生产型审计流程

python demo/audit_pipeline_demo.py


所有演示程序均在 CPU 上运行，不需要 GPU。

# 项目状态

LatentFlowx 是一个实验性研究原型（v1）。

API可能会发生变化

重点在于运行时行为，而非模型性能

欢迎投稿、反馈和批评意见

# 路线图

规划器/执行器/验证器模块（无代理执行）

# 更强的不变性检验

其他成本指标（状态大小、内存压力）

# 多模态块输入

LLM/代理系统的可选集成层

# 执照
Apache 许可证 2.0